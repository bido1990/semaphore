---
- name: Update Ubuntu Server VMs with safe maintenance window (no SIGKILL)
  hosts: ubuntu_vms
  become: true
  become_method: sudo
  gather_facts: yes

  vars:
    uu_log_since: "24h"
    uu_timers:
      - apt-daily.timer
      - apt-daily-upgrade.timer
    apt_lock_timeout: 300
    lock_wait_secs: 600        # how long to wait for locks to clear if stop hangs

  pre_tasks:
    - name: Show unattended-upgrades status (systemctl show)
      ansible.builtin.command: >
        systemctl show unattended-upgrades.service
        -p ActiveState -p SubState -p LoadState -p UnitFileState
      register: uu_show
      changed_when: false

    - name: Print service state
      ansible.builtin.debug:
        msg: "{{ uu_show.stdout }}"

    - name: Show apt timer status
      ansible.builtin.command: "systemctl status {{ item }} --no-pager"
      loop: "{{ uu_timers }}"
      register: timer_status
      changed_when: false

    - name: Print timer status
      ansible.builtin.debug:
        msg: "{{ item.stdout }}"
      loop: "{{ timer_status.results }}"

    - name: Collect recent unattended-upgrades logs from journald (24h)
      ansible.builtin.command: >
        journalctl -u unattended-upgrades
        --since "{{ uu_log_since }}"
        --no-pager
      register: uu_logs
      changed_when: false
      failed_when: false

    - name: Print unattended-upgrades logs (journald, truncated)
      ansible.builtin.debug:
        msg: "{{ uu_logs.stdout | default('no journald logs') | truncate(6000, end='...') }}"

  tasks:
    - name: Stop apt timers first (avoid retriggers)
      ansible.builtin.systemd_service:
        name: "{{ item }}"
        state: stopped
      loop: "{{ uu_timers }}"

    - block:
        - name: Try graceful stop of unattended-upgrades
          ansible.builtin.systemd_service:
            name: unattended-upgrades.service
            state: stopped
          register: uu_stop_result

      rescue:
        - name: Informational note when graceful stop fails
          ansible.builtin.debug:
            msg: "Graceful stop failed; will wait for dpkg/apt locks to clear up to {{ lock_wait_secs }}s"

        - name: Wait for dpkg/apt locks to be released (bounded)
          ansible.builtin.shell: |
            end=$(( $(date +%s) + {{ lock_wait_secs }} ))
            while [ "$(date +%s)" -lt "$end" ]; do
              if fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1 || \
                 fuser /var/lib/dpkg/lock >/dev/null 2>&1 || \
                 fuser /var/lib/apt/lists/lock >/dev/null 2>&1; then
                echo "Lock detected, waiting 10s..."
                sleep 10
              else
                exit 0
              fi
            done
            echo "Timeout waiting for locks" >&2
            exit 1
          register: lock_wait
          changed_when: false

    - name: Update apt cache with lock wait
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600
        lock_timeout: "{{ apt_lock_timeout }}"

    - name: Dist upgrade with cleanup and lock wait
      ansible.builtin.apt:
        upgrade: dist
        autoremove: true
        autoclean: true
        lock_timeout: "{{ apt_lock_timeout }}"
      register: apt_upgrade_result

    - name: Check if reboot is required
      ansible.builtin.stat:
        path: /var/run/reboot-required
      register: reboot_required_file

    - name: Start apt timers after maintenance
      ansible.builtin.systemd_service:
        name: "{{ item }}"
        state: started
      loop: "{{ uu_timers }}"

    - name: Start unattended-upgrades after maintenance
      ansible.builtin.systemd_service:
        name: unattended-upgrades.service
        state: started

    - name: Show next scheduled timers
      ansible.builtin.command: systemctl list-timers --all --no-pager
      register: list_timers
      changed_when: false

    - name: Print next timers (first 30 lines)
      ansible.builtin.debug:
        msg: "{{ list_timers.stdout.splitlines()[:30] | join('\n') }}"

    - name: Reboot server if required
      ansible.builtin.reboot:
        reboot_timeout: 300
        pre_reboot_delay: 5
      when: reboot_required_file.stat.exists

    - name: Verify SSH connectivity after reboot
      ansible.builtin.wait_for_connection:
        connect_timeout: 20
        sleep: 5
        delay: 5
        timeout: 300
      when: reboot_required_file.stat.exists
      
